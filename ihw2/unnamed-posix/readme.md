# Отчёт для программы: 4-5 баллов. Множество процессов взаимодействуют с использованием неименованных POSIX семафоров.

## Код программы

Файл программы - [main.cpp](main.cpp)

## Описание входных данных

В терминале пользователю предлагается ввести энергию Ций каждого из бойцов, после чего начинается соревнование

## Описание алгоритма работы программы

- Создаются три потока для трех парных боев между бойцами. Каждый поток запускает функцию `fight`, передавая двух бойцов из массива и семафор для синхронизации доступа к общим данным.
- В функции `fight` сначала происходит симуляция боя с использованием временной задержки для моделирования продолжительности боя. Затем два бойца соревнуются на силу, и победитель увеличивает свою силу за счет силы проигравшего. Семафор используется для обеспечения взаимоисключения при доступе к общим данным (силе бойцов).
- Функция `finalFight` определяет победителей первых трех боев и организует финальный бой между ними. Победитель первого и второго боя сражаются между собой, а затем победитель этого боя сражается с победителем третьего боя.
- Далее в функции `main` основной поток ожидает завершения всех трех парных боев.
- После завершения всех боев определяется сила победителя соревнования и выводится на экран.
- В конце программы все семафоры уничтожаются для освобождения ресурсов.
  
## Описание кода программы

Для модели бойцов используется структура Fighter, которая содержит в полях всю необходимую информацию об определенном бойце.
```cpp
struct Fighter {
    int strength;
    bool defeated;

    explicit Fighter(int str) : strength(str), defeated(false) {}
};
```

Функция `fight` моделирует бой между двумя бойцами. Она засыпает на время, равное доле силы бойца 2 относительно силы бойца 1. После этого определяет победителя, опираясь на силы бойцов и обновляет его силу. Семафор `semaphore` используется для синхронизации доступа к общим данным.
```cpp
void fight(Fighter& fighter1, Fighter& fighter2, sem_t& semaphore) {
    std::this_thread::sleep_for(std::chrono::milliseconds (fighter2.strength / fighter1.strength * 1000));

    sem_wait(&semaphore);
    // ...
    sem_post(&semaphore);
}
```

Функция `finalFight` определяет победителей первых трех боев и устраивает между ними финальные поединки. Она также использует семафор для синхронизации доступа к общим данным.
void finalFight(std::vector<Fighter>& fighters, sem_t& semaphore) {
    // ...
}

Ввод необходимых данных.
```cpp
 std::vector<Fighter> fighters;
    for (int i = 0; i < numFighters; ++i) {
        int strength;
        printf("Введите энергию Ций бойца %d: ", i + 1);
        std::cin >> strength;
        fighters.emplace_back(strength);
    }

    printf("\nИнформация об энергиях Ций бойцов:\n");
    for (int i = 0; i < numFighters; ++i) {
        printf("Боец %d: %d\n", i + 1, fighters[i].strength);
    }
    printf("\n");
```

Для начала соревнования создаются три потока для трех парных боев между бойцами. Каждый поток запускает функцию `fight`, передавая каждого из бойцов и семафор в качестве входных данных.
```cpp
std::thread fights[3];
for (int i = 0; i < 3; ++i) {
    fights[i] = std::thread(fight, std::ref(fighters[i * 2]), std::ref(fighters[i * 2 + 1]), std::ref(semaphore));
}
```

Определение победителя соревнований и вывод итоговый силы победившего бойца
```cpp
int winner_strength = -1;
for (const auto& fighter : fighters) {
    if (!fighter.defeated) {
        winner_strength = fighter.strength;
        break;
    }
}
if (winner_strength != -1) {
    std::cout << "Сила победителя соревнования: " << winner_strength << std::endl;
} else {
    std::cout << "Все бойцы были побеждены." << std::endl;
}
```

## Пример выполнения программы

![Снимок экрана 2024-04-19 в 12 42 30](https://github.com/flowykk/operating-sys-hse/assets/71427624/b34e272e-c640-4a11-a353-1cb3f9abbe70)
