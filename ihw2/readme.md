# ИДЗ №2

__Работу выполнил__: Рахманов Данила Дмитриевич

__Вариант__: 31

__Условие задачи__: Задача о Пути Кулака. На седых склонах Гималаев стоит древний буддистский монастырь: Гуань-Инь-Янь. Каждый год в день сошествия на землю боддисатвы монахи монастыря собираются на совместное празднество и показывают свое совершенствование на Пути Кулака. Всех соревнующихся монахов первоначально разбивают на пары. Бои продолжаются до выявления победителя. Мо26 нах который победил в финальном бою, забирает себе на хранение статую боддисатвы. Реализовать многопроцессное приложение, определяющего победителя. В качестве входных данных используется массив, в котором хранится количество энергии Ци каждого монаха. При победе монах забирает энергию Ци своего противника. Новые пары образуются среди победителей других пар в порядке завершения поединков. То есть, возможна ситуация, когда бойцы, участвующие в поединке могут быстро победить и начать биться с другими, в то время как поединки начавшиеся ранее, могут продолжаться. Причем длительное время. Каждый поединок протекает некоторое случайное время, которое пропорционально отношению энергии Ци побежденного к энергии Ци победителя, умноженному на поправочный коэффициент, позволяющий отслеживать протекание поединка на экране дисплея (например, путем умножения этого отношения на 1000 миллисекунд или другое более удобное значение).

## Что сделано в ИДЗ №1?

### Оценка 4-5:
- Разработана программа, ...
- Отдельный отчёт можно посмотреть [тут](named-posix/)

### Оценка 6-7:
- Разработана программа, ...
- Отдельный отчёт можно посмотреть [тут](unnamed-posix/)
  
### Оценка 8:
- Разработана программа, ...
- Отдельный отчёт можно посмотреть [тут](two-relative-named/)

## Общий код, присутствующий во всех решениях

Для модели бойцов используется структура Fighter, которая содержит в полях всю необходимую информацию об определенном бойце.
```cpp
struct Fighter {
    int strength;
    bool defeated;

    explicit Fighter(int str) : strength(str), defeated(false) {}
};
```

Функция `fight` моделирует бой между двумя бойцами. Она засыпает на время, равное доле силы бойца 2 относительно силы бойца 1. После этого определяет победителя, опираясь на силы бойцов и обновляет его силу. Семафор `semaphore` используется для синхронизации доступа к общим данным.
```cpp
void fight(Fighter& fighter1, Fighter& fighter2, sem_t& semaphore) {
    std::this_thread::sleep_for(std::chrono::milliseconds (fighter2.strength / fighter1.strength * 1000));

    sem_wait(&semaphore);
    // ...
    sem_post(&semaphore);
}
```

Функция `finalFight` определяет победителей первых трех боев и устраивает между ними финальные поединки. Она также использует семафор для синхронизации доступа к общим данным.
void finalFight(std::vector<Fighter>& fighters, sem_t& semaphore) {
    // ...
}

## Скриншоты, демонстрирующие работу программы 

### Примеры работы программ на оценки 4-7

#### Пример 1
![Снимок экрана 2024-04-19 в 17 18 43](https://github.com/flowykk/operating-sys-hse/assets/71427624/b207d423-9e35-4ccd-a808-453385feeda0)

#### Пример 2
![Снимок экрана 2024-04-19 в 17 19 56](https://github.com/flowykk/operating-sys-hse/assets/71427624/f6873f96-3133-4e08-b392-a4dcb1190d69)

### Пример работы программ на оценки 8+

#### Терминал при запуске Программы 1
![Снимок экрана 2024-04-19 в 17 17 19](https://github.com/flowykk/operating-sys-hse/assets/71427624/a01a4e9e-38f7-4daa-8fbf-65c6da32573b)

#### Терминал при запуске Программы 2
![Снимок экрана 2024-04-19 в 17 17 40](https://github.com/flowykk/operating-sys-hse/assets/71427624/7f3218cf-3232-4806-a3ca-fe883ecb5c0c)
